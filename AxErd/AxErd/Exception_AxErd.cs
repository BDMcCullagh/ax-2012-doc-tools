// C#.  Change at each 'Application-specific' find, per application.
//    2013-Feb-01

using System;
using SysTex = System.Text;



namespace AxErd // Application-specific
{

	class Exception_AxErd // Application-specific
			: ApplicationException
	{

		// Constructor.


		/// <summary>
		/// General application exception generated by logic of this application.
		/// </summary>
		/// <param name="_sMessageIdAppSpecific"></param>
		/// <param name="_sMessageTextAppSpecific"></param>
		/// <param name="_sMessageTextLineSpecific"></param>
		/// <param name="_exceptionInner">
		/// </param>
		public Exception_AxErd
				(
				string _sMessageIdAppSpecific,
				string _sMessageTextAppSpecific,
				string _sMessageTextLineSpecific,
				Exception _exceptionInner
				)
			: base  // Like 'super() in X++.
				(
					Exception_AxErd.BuildParameterForBaseCtor  // 'base' keyword requires that this method be static.
						(
						_sMessageIdAppSpecific,
						_sMessageTextAppSpecific,
						_sMessageTextLineSpecific
						),
					_exceptionInner
				)
		{
			this.m_sMessageIdAppSpecific = _sMessageIdAppSpecific;
			this.m_sMessageTextAppSpecific = _sMessageTextAppSpecific;
			this.m_sMessageTextLineSpecific = _sMessageTextLineSpecific;
		}



		/// <summary>
		/// Used to partially overcome a limitation in the design of C# base .ctor keyword.
		/// </summary>
		/// <param name="_sMessageIdAppSpecific">Such as "MyAddNickCode_Error_1234ab1".
		/// </param>
		/// <param name="_sMessageTextAppSpecific">Exception.Message mainly.
		/// </param>
		/// <param name="_sMessageTextLineSpecific">Maybe unnecessary due to Exception.Data?
		/// </param>
		/// <returns>string for .ctor of Exception.Message .
		/// </returns>
		static public string BuildParameterForBaseCtor
				(
				string _sMessageIdAppSpecific,
				string _sMessageTextAppSpecific,
				string _sMessageTextLineSpecific
				)
		{
			SysTex.StringBuilder sbuilder = new SysTex.StringBuilder(512);
			//

			sbuilder.Append(_sMessageIdAppSpecific);
			sbuilder.AppendLine(":");
			sbuilder.AppendLine(_sMessageTextAppSpecific);
			sbuilder.AppendLine(_sMessageTextLineSpecific);

			return sbuilder.ToString();
		}



		// Fields.
		private bool m_bAlreadyCaughtAndProcessed = false;
		private string m_sMessageIdAppSpecific;
		private string m_sMessageTextAppSpecific; // This text applies to multiple lines.
		private string m_sMessageTextLineSpecific; // This text has details specific to the current line where this exception is being generated.




		/// <summary>
		/// IsAlreadyCaughtAndProcessed = true
		/// ...might be a good idea, after this string is logged for user to see.
		/// </summary>
		/// <returns></returns>
		public string ToStringApp()
		{
			SysTex.StringBuilder sbuilder = new SysTex.StringBuilder(512);
			//

			sbuilder.AppendLine(this.m_sMessageIdAppSpecific);
			sbuilder.AppendLine(this.m_sMessageTextAppSpecific);
			sbuilder.AppendLine(this.m_sMessageTextLineSpecific);
			sbuilder.AppendLine(this.m_bAlreadyCaughtAndProcessed.ToString());

			return sbuilder.ToString();
		}




		// Properties, formal.

		/// <summary>
		/// Test this returned value before logging or otherwise processing
		/// this exception when catching it,
		/// to ascertain whether it has already been processed (such as Logged, etc).
		/// 
		/// Consider .ToStringApp() content logging as possible grounds for =true.
		/// </summary>
		public bool IsAlreadyCaughtAndProcessed
		{
			get { return this.m_bAlreadyCaughtAndProcessed; }
			set { this.m_bAlreadyCaughtAndProcessed = value; }
		}


		// Properties, pseudo.

		public string GetMessageIdAppSpecific() { return this.m_sMessageIdAppSpecific; }
		public string GetMessageTextAppSpecific() { return this.m_sMessageTextAppSpecific; }
		public string GetMessageTextLineSpecific() { return this.m_sMessageTextLineSpecific; }

	} // EOClass
}
